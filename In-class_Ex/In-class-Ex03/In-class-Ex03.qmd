---
title: "Hands-On Exercise 3 : "

execute: 
  warning: false
date: "`r Sys.Date()`"
---

```{r}

pacman::p_load(maptools, sf,raster,spatstat,tmap,tidyverse)
```

Here we use two different types of reading because for childcare we know the exact file but the other file is a shapefile that requires multiple files, so you use the dsn part.

```{r}
childcare_sf <- st_read("../../Hands-On_Ex/Hand-on_Ex03/data/ChildCareServices.geojson") %>%
  st_transform(crs=3414)
mpsz_sfe <- st_read(dsn="data/geospatial", layer="MP14_SUBZONE_WEB_PL")

```

```{r}
class(mpsz_sfe)
```

## Creating Coastal outline

When you apply **`st_union()`** to a collection of polygons, each representing a state within a country, the function merges all these state polygons into a single polygon that represents the entire country, effectively dissolving the boundaries (state lines) between them.

```{r}
sg_sf <- mpsz_sfe %>%
  st_union()
# st_combine combines geometries wirhout dissolve/resolve boundaries but st_union does
```

```{r}
plot(sg_sf)
```

## geospatial data wrangling

creating ppp objects : sf method

easier to do this to get from sf -\> ppp, instead of sf -\> sp\* -\> sp general -\> ppp

```{r}
childcare_ppp <- as.ppp(childcare_sf)
```

```{r}
summary(childcare_ppp)
```

```{r}
plot(childcare_ppp)
```

### Handling duplicated points

We can check the duplication in a ppp object by using the code chunk below.

This is very important for postal code data. Postal code covers a large area and muliple data points have the same postal code, so you must check if there are duplicates + use jittering

```{r}
any(duplicated(childcare_ppp))
```

### Creating owin object : sf method

This .owin helps with the conversion aagain without you doing sf -\> sp\* -\> sp general -\> owin

```{r}
# . functions work with sf layer, so take the originl data
sg_owin <- as.owin(sg_sf)
```

```{r}
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

```{r}
childcareSG_ppp <- childcare_ppp[sg_owin]
```

```{r}
pg <- mpsz_sfe %>% 
  filter(PLN_AREA_N == "PUNGGOL")
tm <- mpsz_sfe %>% 
  filter(PLN_AREA_N == "TAMPINES")
ckk <- mpsz_sfe %>% 
  filter(PLN_AREA_N == "CHOA CHU KANG")
jw <- mpsz_sfe %>% 
  filter(PLN_AREA_N == "JURONG WEST")
```

Plotting target planning area

```{r}

plot(pg, main ="Punggol")

```

```{r}
plot(tm, main ="Tampines")

```

```{r}
plot(ckk, main ="Chua Chu Kang")

```

```{r}
plot(jw, main ="Jurong West")
```

## Network constrained kernel density

## Getting started

```{r}
pacman::p_load(sp,rgdal,sf, spNetwork, tmap, classInt, viridis, tidyverse)
```

## 2. Data Import and Preparation

```{r}
network <- st_read(dsn="data/geospatial", layer="Punggol_St")
```

```{r}
childcareNew <- st_read(dsn="data/geospatial", layer="Punggol_CC")
```

### Change projection system

```{r}
childcareNew <-childcareNew %>% st_transform(crs =3414)

network <-network  %>% st_transform(crs =3414)

```

### Plot

```{r}
tmap_mode('plot')
tm_shape(childcareNew) + 
  tm_dots() + 
  tm_shape(network) +
  tm_lines()
```

```{r}
lixels <- lixelize_lines(network,750,mindist = 375)
```

length of a lixel is set to 750m and min length of a lixel is set to 375

```{r}
samples <- lines_center(lixels)
```

```{r}
densities <- nkde(network, 
                  events = childcareNew,
                  w = rep(1,nrow(childcareNew)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```
