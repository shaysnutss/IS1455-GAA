## Overview

here we are doing spatial point analysis where we are basically studying and analysing the spread of points in a space.

It helps us answer tje following questions:

1.  are the childcare centres in Singapore randomly distributed throughout the country?
2.  if the answer is not, then the next logical question is where are the locations with higher concentration of childcare centres?

## 

## Data

1.  childcare
2.  MP14_SUBZONE_WEB_PL
3.  CostalOutline

## Installing and loading the R packages

We need to install and load the R packages into the R environment to use them

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap)
```

If you aren't able to install maptools, do this:

```{r}
install.packages("maptools", repos="http://R-Forge.R-project.org")


```

## Spatial Data Wrangling

### Importing the spatial data

We will use the st_read() function of sf package to import geospatial datasets into R.

Let's import the first one of ChildCareServices:

```{r}
childcare_sf <- st_read("data/ChildCareServices.geojson")
```

We can see that the CRS is not what we want let's transform it to SVY21

```{r}
childcare_sf <- st_transform(childcare_sf, crs = 3414)
```

Let's print out childcare_sf to see what is the CRS.

```{r}
st_geometry(childcare_sf)
```

Let's import coastal outline.

```{r}
sg_sf <- st_read(dsn = "data/geospatial", layer="CostalOutline")

```

When we look at the coordinate reference system of coastal outline, we see that the user input is SVY21 but the correct EPSG code is 9001 instead of 3414.

```{r}
st_crs(sg_sf)
```

So here we change it to 3414.

Reminder we don't use st_transform() because the CRS is already SVY21, it's just the ESPG code that is wrong!

```{r}

sg_sf <- st_set_crs(sg_sf, 3414)
```

Now let's recheck if the coordiante system and ESPG code match.

```{r}
st_crs(sg_sf)
```

Now let's import MP_14_SUBZONE_WEB_PL.

```{r}
mpsz_sf <- st_read(dsn = "data/geospatial", 
                layer = "MP14_SUBZONE_WEB_PL")
```

Let's check the coordinate system, it has to be SVY21 so that it is projected coordinate system, and the ESPG code has to match the SVY21.

```{r}
st_crs(mpsz_sf)
```

Since it's 9001 and not 3414, let's change the code.

```{r}
mpsz_sf <- st_set_crs(mpsz_sf, 3414)
```

Let's check.

```{r}
st_crs(mpsz_sf)
```

### Mapping the Geospatial data sets

```{r}
col_names <- names(childcare_sf)
print(col_names)
```

```{r}
tmap_mode("plot")
tm_shape(mpsz_sf) +
  tm_polygons() +
  tm_shape(childcare_sf) +  
  tm_dots()
```

## Geospatial Data Wrangling

Although simple feature data frame is gaining popularity again sp’s Spatial\* classes, there are, however, many geospatial analysis packages require the input geospatial data in sp’s Spatial\* classes. In this section, you will learn how to convert simple feature data frame to sp’s Spatial\* class.

### **Converting sf data frames to sp’s Spatial\* class**

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

```{r}
#print(as.data.frame(childcare))
```

```{r}
#childcare
```

```{r}
#mpsz
```

```{r}
#sg
```

### **Converting the Spatial\* class into generic sp format**

**spatstat** requires the analytical data in ***ppp*** object form. There is no direct way to convert a Spatial\* classes into ***ppp*** object. 

Spatial\* classes -\> Spatial -\> ppp

Let's do spatial\* classes -\> spatial first

Remeber to use the correct type of shape

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

**What are the differences between Spatial\* classes and generic sp object?**

In summary, you would use Spatial\* classes when you have simple spatial data without additional attributes, and you want a straightforward representation of points, lines, or polygons. On the other hand, if your spatial data includes associated attributes and you need to perform in-depth analysis, you would use generic sp objects like SpatialPointsDataFrame or SpatialPolygonsDataFrame.

For example, if you only need to plot the locations of childcare centers on a map, you can use the SpatialPoints class. However, if you want to perform statistical analysis on the childcare data, including attributes such as capacity or age group, you would convert it into a SpatialPointsDataFrame, which allows you to work with both spatial and attribute data seamlessly.

### **Converting the generic sp format into spatstat’s ppp format**

sp -\> ppp. And now you can put it into spatstat.

Now, we will use *as.ppp()* function of **spatstat** to convert the spatial data into **spatstat**’s ***ppp*** object format.

```{r}
childcare_ppp <- as(childcare_sp, "ppp")
childcare_ppp
```

```{r}
plot(childcare_ppp)
```

**what's the difference between plotting a geojson with spatial points and plotting the same data thats converted to ppp format**

Plotting a GeoJSON file with spatial points typically results in a standard spatial point map. Each point is displayed as a symbol or marker on the map, and you can customize the appearance of the points, such as color, size, and shape.

Converting data to **`ppp`** format is typically done when you intend to perform spatial point process analysis. In this context, a point pattern represents the locations of events or objects of interest (e.g., tree locations, disease cases). **`ppp`** objects are used in the **`spatstat`** package for advanced spatial point pattern analysis. This includes tasks like assessing spatial clustering, estimating intensity, performing K-functions analysis, and simulating point patterns under different models.

```{r}
summary(childcare_ppp)
```

### **Handling duplicated points**

Duplicates, in this context, are multiple points that occupy exactly the same location in space.

Coincident points are points that are so close to each other that they are considered to occupy the same location within a certain tolerance threshold.

These duplicates or coincident points can occur for various reasons, such as measurement errors, data collection methods, or the nature of the phenomenon being studied.

Let's check if there are any duplicates in the data:

```{r}
any(duplicated(childcare_ppp))
```

The **`multiplicity()`** function is a function or method typically provided by spatial point pattern analysis software or packages like **`spatstat`**. Its purpose is to calculate the multiplicity of points in a point pattern. Multiplicity refers to the number of points that occupy the same location (coincident points) at each location where such coincidences occur.

```{r echo = T, results = 'hide'}
# Count the number of coincident
#points in the childcare_ppp point pattern
multiplicity(childcare_ppp)

```

```{r}
tmap_mode('plot')
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

There are three different approaches to address the issue of duplicate points in spatial point pattern analysis:

1.  **Deleting Duplicates**: This is the simplest approach, where you remove the duplicate points from your dataset. However, this method comes with a drawback, as it may result in the loss of valuable point events. If each point represents a meaningful observation, deleting duplicates can lead to the omission of important data.

2.  **Jittering**: The second solution involves adding a small random perturbation to the duplicate points. This perturbation is often referred to as "jitter," and it introduces a slight variation in the spatial locations of duplicate points, ensuring that they do not occupy the exact same space. Jittering is a way to retain all points while avoiding the issue of perfect overlap.

3.  **Attaching Duplicates as Marks**: The third solution is to treat each point as "unique" and then attach the duplicates of the points as marks or attributes of the points. In this approach, duplicate points are not removed or perturbed; instead, they are associated with additional information or attributes. This allows you to preserve all observations while acknowledging their duplications. Analytical techniques that consider these marks can be applied to study the spatial pattern or relationships among points.

#### Jittering

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

Let's check if there are any duplicate points

```{r}
any(duplicated(childcare_ppp_jit))
```

### **Creating *owin* object**

The owin object is essentially a spatial window that limits the analysis to a specific polygonal region. It provides a framework for handling point patterns within this spatial window. This is particularly important when you want to account for the geographic boundaries of the study area in your analysis.

```{r}
# this is from generic spatia lclass to owin
sg_owin <- as(sg_sp, "owin")
```

```{r}
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

### **Combining point events object and owin object**

In this last step of geospatial data wrangling, we will extract childcare events that are located within Singapore by using the code chunk below.

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
```

```{r}
plot(childcareSG_ppp)
```

## **First-order Spatial Point Patterns Analysis**

-   deriving **kernel density estimation (KDE)** layer for visualising and exploring the intensity of point processes

-   performing **Confirmatory Spatial Point Patterns Analysis** by using **Nearest Neighbour** statistics

### **Kernel Density Estimation**

#### Computing kernel density estimation using automatic bandwidth selection method

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

Code walkthrough:

-   density: estimate density of a dataset

-   sigma=bw.diggle

    -   sigma refers to the bandwidth / radius of the circle/base of the hill. remember, each hill would be given a weight at its peak and it slowly gradually decreases as it goes to the sides.

    -   bw.diggle is how we calculate the bandwidth

    -   kernel=gaussian refers to the smoothening method. we know the density is the top of the hill, and how it smoothens out to the edges of the hill is controlled by the kernel method

```{r}
plot(kde_childcareSG_bw)
```

The density values of the output range from 0 to 0.000035 which is way too small to comprehend. This is because the default unit of measurement of svy21 is in meter. As a result, the density values computed is in “number of points per square meter”.

How do you recover bandwidth:

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

#### Rescalling KDE values

kde_childcareSG_bw stores the density information / the density at different parts of the geographic space.

Normally, density in the context of kernel density estimation is expressed in terms of "number of points per unit area." Since the unit here is meters, the density is being expressed as "number of points per square meter." This means that the value you see (like 0.000035) represents how many points you would expect to find in a square meter of space.

**Why the Values are Small**: Given that a square meter is a relatively small area for most geographical data (like locations of childcare centers, if that's what your data represents), it's common for the density values to be very small, especially if the points (childcare centers in this example) are not extremely densely packed.

In practical terms, when dealing with such small values in a large area (like a city or country), we might consider transforming the scale of your data or adjusting the units of measurement to make the data more interpretable. For instance, we could convert the densities into "number of points per square kilometer" by multiplying the densities by 1,000,000 (since there are 1,000,000 square meters in a square kilometer). This could make the values more comprehensible in a broader geographical context.

In the code chunk below, *rescale()* is used to covert the unit of measurement from meter to kilometer.

```{r}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

```{r}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")

plot(kde_childcareSG.bw)
```

Notice that output image looks identical to the earlier version, the only changes in the data values (refer to the legend).

### **Working with different automatic badwidth methods**

Beside *bw.diggle()*, there are three other **spatstat** functions can be used to determine the bandwidth, they are: *bw.CvL()*, *bw.scott()*, and *bw.ppl()*.

```{r}
 bw.CvL(childcareSG_ppp.km)
```

```{r}
bw.scott(childcareSG_ppp.km)
```

```{r}
bw.ppl(childcareSG_ppp.km)
```

```{r}
bw.diggle(childcareSG_ppp.km)
```

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

### **Working with different kernel methods**

By default, the kernel method used in *density.ppp()* is *gaussian*. But there are three other options, namely: Epanechnikov, Quartic and Dics.

The code chunk below will be used to compute three more kernel density estimations by using these three kernel function.

par(mfrow=c(2,2)) plot(density(childcareSG_ppp.km, sigma=bw.ppl, edge=TRUE, kernel="gaussian"), main="Gaussian") plot(density(childcareSG_ppp.km, sigma=bw.ppl, edge=TRUE, kernel="epanechnikov"), main="Epanechnikov") plot(density(childcareSG_ppp.km, sigma=bw.ppl, edge=TRUE, kernel="quartic"), main="Quartic") plot(density(childcareSG_ppp.km, sigma=bw.ppl, edge=TRUE, kernel="disc"), main="Disc")

## **Fixed and Adaptive KDE**

### **Computing KDE by using fixed bandwidth**

Next, you will compute a KDE layer by defining a bandwidth of 600 meter. Notice that in the code chunk below, the sigma value used is 0.6. This is because the unit of measurement of ***childcareSG_ppp.km*** object is in kilometer, hence the 600m is 0.6km.

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")

plot(kde_childcareSG_600)
```

### **Computing KDE by using adaptive bandwidth**

Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.

In this section, you will learn how to derive adaptive kernel density estimation by using [*density.adaptive()*](https://rdrr.io/cran/spatstat/man/adaptive.density.html) of **spatstat**.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

### **Converting KDE output into grid object**

A grid object in spatial analysis represents a regular tessellation of a surface into cells or squares, each with its own value. In the context of KDE output, each cell in the grid would represent the estimated density of points within that cell.

[Why do we do this?]{.underline}

**Cell-wise Comparisons**: Once the KDE output is in a grid format, you can perform cell-wise comparisons or calculations. For example, you might want to find areas where the density exceeds a certain threshold or calculate the total area that has a density within a specific range.

**Integration with GIS Tools**: Many Geographic Information System (GIS) tools are optimized to work with grid data. Converting KDE output to a grid format makes it easier to use these tools for further analysis, modeling, or mapping.

Let's convert

```{r}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG.bw)

spplot(gridded_kde_childcareSG_bw)
```

#### Converting gridded output into raster

[Why do we do this?]{.underline}

Both raster data and gridded outputs represent spatial information using a grid format, but they serve slightly different purposes and have varying degrees of compatibility with Geographic Information Systems (GIS) and third-party tools.

-   **Interoperability with GIS and Tools**: While both gridded outputs and raster data are grid-formatted, raster data is specifically formatted for and thus more directly interoperable with GIS software and third-party tools. Raster formats are designed to be easily imported, manipulated, analyzed, and visualized in GIS platforms.

-   **Metadata and Georeferencing**: Raster datasets typically include metadata and georeferencing information, making them immediately useful for spatial analyses without requiring additional steps to define the spatial extent, projection, or coordinate system.

-   **Efficiency and Compatibility**: Raster formats often support compression, pyramids for efficient zooming, and spatial indexing, which enhances their performance in GIS applications. They are widely supported across different platforms, ensuring compatibility and ease of use in various analyses and application contexts.

Next, we will convert the gridded kernal density objects into RasterLayer object by using *raster()* of **raster** package.

```{r}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
```

Let us take a look at the properties of *kde_childcareSG_bw_raster* RasterLayer.

```{r}
kde_childcareSG_bw_raster
```

**`dimensions: 128, 128, 16384`**:

-   **`nrow`**: The raster has 128 rows.

-   **`ncol`**: The raster has 128 columns.

-   **`ncell`**: The total number of cells (or pixels) in the raster is 16,384, which is the product of the number of rows and columns (128 x 128).

**`resolution: 0.4170614, 0.2647348` (x, y)**: This specifies the size of each cell in the units of the raster's coordinate reference system (CRS). The first number is the width of each cell (x-direction), and the second number is the height of each cell (y-direction). This tells you how much geographic area each pixel represents.

#### Assigning projection systems

We saw that there was no projection system on the raster variable. So let's assign it!

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

### **Visualising the output in tmap**

Finally, we will display the raster in cartographic quality map using **tmap** package

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

if i did not put tm_raster i would have put tm_fill or tm_polgon.**`tm_raster`**, **`tm_fill`**, and **`tm_polygon`** are functions used within the **`tmap`** package in R to add different types of layers to a map,

**`tm_raster`** is specifically designed for adding and visualizing raster data layers on a map.

### **`tm_fill` and `tm_polygon`**

-   **`tm_fill`**: This function is used to add and visualize areas on a map by filling them with colors based on their attributes. It's often used with spatial polygons data where each polygon represents a distinct area, such as countries, states, districts, or other regions.

-   **`tm_polygon`**: Very similar to **`tm_fill`**, **`tm_polygon`** is used to add polygon layers to a map. It can fill the polygons with color based on their attributes and also allows for the customization of border colors and styles. Essentially, **`tm_fill`** is a shortcut for **`tm_polygon`** with a focus on filling the polygons rather than styling their borders.

### **Comparing Spatial Point Patterns using KDE**

In this section, you will learn how to compare KDE of childcare at Ponggol, Tampines, Chua Chu Kang and Jurong West planning areas

#### 4.7.5.1 Extracting study area

The code chunk below will be used to extract the target planning areas.

```{r}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

```{r}
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

#### Converting the spatial point data frame into generic sp format

so mspz, and any data from it was converted from sf to sp's spatial\* class

In summary, you would use Spatial\* classes when you have simple spatial data without additional attributes, and you want a straightforward representation of points, lines, or polygons. On the other hand, if your spatial data includes associated attributes and you need to perform in-depth analysis, you would use generic sp objects like SpatialPointsDataFrame or SpatialPolygonsDataFrame.

```{r}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

#### Creating ***owin*** object

Now, we will convert these SpatialPolygons objects into owin objects that is required by **spatstat**.

spatstat cant take generic sp obejcts and tehy need to be converted into owin objects

This is so that we confine our geospatial analysis to that area.

##### **Converting `sp` Objects to `spatstat` Objects**

To use **`sp`** objects with **`spatstat`**, you generally need to convert them into a format that **`spatstat`** understands:

-   **From `sp` to `owin`**: If you have a spatial polygons object from the **`sp`** package that defines the study area or observation window, you would convert it to an **`owin`** object to define the observation window in **`spatstat`**.

-   **From `sp` Point to `ppp`**: Similarly, if you have point data in an **`sp`** format, you would convert it to a **`ppp`** object (point pattern object) for analysis in **`spatstat`**.

```{r}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

childcare_ppp_jit was made when we tried to remove duplicated points. And that was made from childcare_ppp that was made from an sp object, as ppp objects were needed to put into the spatstat object for spatial analysis.

#### Combining childcare points and the study area

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

Next, *rescale()* function is used to trasnform the unit of measurement from metre to kilometre.

```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

The code chunk below is used to plot these four study areas and the locations of the childcare centres.

```{r}

plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

#### Computing KDE

Let's compute KDE in each location!

```{r}
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
```

#### Computing fixed bandwidth KDE

For comparison purposes, we will use 250m as the bandwidth

```{r}

plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

## **Nearest Neighbour Analysis**

In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using [*clarkevans.test()*](https://www.rdocumentation.org/packages/spatstat/versions/1.63-3/topics/clarkevans.test) of **statspat**.

The test hypotheses are:

Ho = The distribution of childcare services are randomly distributed.

H1= The distribution of childcare services are not randomly distributed.

The 95% confident interval will be used.

### **Testing spatial point patterns using Clark and Evans Test**

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

### **Clark and Evans Test: Choa Chu Kang planning area**

In the code chunk below, [*clarkevans.test()*](https://rdrr.io/cran/spatstat/man/clarkevans.test.html) of **spatstat** is used to performs Clark-Evans test of aggregation for childcare centre in Choa Chu Kang planning area.

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

### **Clark and Evans Test: Tampines planning area**

```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```
